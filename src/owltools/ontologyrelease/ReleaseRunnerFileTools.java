package owltools.ontologyrelease;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileFilter;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.HashSet;
import java.util.Properties;
import java.util.Set;

import org.apache.commons.io.FileUtils;
import org.apache.commons.io.IOUtils;
import org.apache.log4j.Logger;

/**
 * Provide a staging directory for the release runners. 
 */
abstract class ReleaseRunnerFileTools {

	private static final String EXTENSIONS_DIRECTORY_NAME = "extensions";
	private static final String SUBSETS_DIRECTORY_NAME = "subsets";
	private static final String RELEASE_DIRECTORY_NAME = "releases";
	private static final String STAGING_DIRECTORY_NAME = "staging";
	private static final String STAGING_DIRECTORY_LOCK_FILE_NAME = ".lock";
	private static final String VERSION_INFO_FILE_NAME = "VERSION-INFO";
	
	private final File base;
	private final File staging;
	private final File lockFile;
	private final Logger logger;

	/**
	 * @param base directory
	 * @param logger
	 * @throws IOException
	 */
	ReleaseRunnerFileTools(File base, Logger logger) throws IOException {
		super();
		this.logger = logger;
		
		// base
		this.base = base;
		checkFolder(base);
		
		// staging directory
		staging = new File(base, STAGING_DIRECTORY_NAME);
		checkFolder(staging);
		
		// lock file
		lockFile = new File(staging, STAGING_DIRECTORY_LOCK_FILE_NAME);
		boolean success = lockFile.createNewFile();
		if (!success) {
			if (!forceLock(lockFile)) {
				throw new IOException("Could not lock staging directory via lock file: "+lockFile.getAbsolutePath());
			}
			FileUtils.touch(lockFile);
		}
		logger.info("Using staging folder for release manager: "+staging.getAbsolutePath());
		
		// clean staging
		cleanDirectory(staging, STAGING_DIRECTORY_LOCK_FILE_NAME);
		
		// sub directories
		File subsets = new File(staging, SUBSETS_DIRECTORY_NAME);
		checkFolder(subsets);

		File extensions = new File(staging, EXTENSIONS_DIRECTORY_NAME);
		checkFolder(extensions);
	}
	
	boolean forceLock(File file) {
		return false;
	}
	
	BufferedWriter getWriter(String fileName) throws IOException {
		return new BufferedWriter(new OutputStreamWriter(getOutputSteam(fileName), "UTF-8"));
	}
	
	OutputStream getOutputSteam(String fileName) throws IOException {
		// fail early, if the release manager would try to overwrite an existing file in the commit.
		checkNew(new File(base, fileName));
		// cleared: either overwrite is okay or is a new file 
		// But keep working in the staging directory
		File stagingFile = new File(staging, fileName);
		logger.info("saving to " + stagingFile.getAbsolutePath());
		return new FileOutputStream(stagingFile);
	}
	
	/**
	 * Set the ontology version id for a particular release. 
	 * If null, the current date is used.
	 * 
	 * @param version, version if available or null
	 * @return version
	 * @throws IOException
	 */
	String buildVersionInfo(String version) throws IOException {
		// fail early, if the release manager would try to overwrite an existing file in the commit.
		checkNew(new File(base, VERSION_INFO_FILE_NAME));
		// cleared: either overwrite is okay or is a new file 
		// But keep working in the staging directory
		File versionFile = checkNew(new File(staging, VERSION_INFO_FILE_NAME));
		logger.info("Creating version file: "+versionFile.getAbsolutePath());
		FileOutputStream outputStream = null;
		try {
			outputStream = new FileOutputStream(versionFile);
			String comments = null;
			if (version == null) {
				version = OntologyVersionTools.format(new Date());
				comments = "Auto Generated Version Number. Please do not edit this file.";
			}
			
			Properties prop = new Properties();
			prop.setProperty("version", version);
			prop.store(outputStream, comments);
			
			return version;
		}
		finally {
			IOUtils.closeQuietly(outputStream);
		}
	}
	
	private String readVersionInfo() {
		File versionFile = new File(base, VERSION_INFO_FILE_NAME);
		if (!versionFile.exists() || !versionFile.isFile() || !versionFile.canRead()) {
			return null;
		}
		FileInputStream inputStream = null;
		try {
			inputStream = new FileInputStream(versionFile);
			Properties prop = new Properties();
			prop.load(inputStream);
			return prop.getProperty("version");
		} catch (IOException e) {
			logger.info("Could not load old version info from file: "+versionFile.getAbsolutePath(), e);
		} finally {
			IOUtils.closeQuietly(inputStream);
		}
		return null;
	}
	
	/**
	 * Check whether the file is new. Throw an {@link IOException}, 
	 * if the file already exists and {@link #allowFileOverWrite} 
	 * is not set to true.
	 * 
	 * @param file
	 * @return file return the same file to allow chaining with other operations
	 * @throws IOException
	 */
	abstract File checkNew(File file) throws IOException;
	
	/**
	 * Create a release with the files in the staging directory.
	 * Skip the release, if the previous release has equal content.
	 * 
	 * @param version
	 * @return true, if the commit and copy was done.
	 * @throws IOException
	 */
	boolean commit(String version) throws IOException {
		try {
			File releasesFolder = new File(base, RELEASE_DIRECTORY_NAME);
			checkFolder(releasesFolder);
			
			// check if staging folder content is different than the last release
			String oldVersion = readVersionInfo();
			if (oldVersion != null) {
				File oldVersionFolder = new File(releasesFolder, oldVersion);
				if (oldVersionFolder.exists() && oldVersionFolder.isDirectory()) {
					boolean equals = checkOldVersion(oldVersionFolder);
					if (equals) {
						//skip release with message
						logger.info("Skipping release, as the newly generated files do not differ from last release.");
						return false;
					}
				}
				// overwrite base folder content (if there is any)
				// as the user already must have allowed it, to get to this part of the code.
			}
			// make version specific releases sub folder
			File versionFolder = new File(releasesFolder, version);
			checkFolder(versionFolder);
			
			// copy from staging directory into version specific releases folder
			copyContents(staging, versionFolder, STAGING_DIRECTORY_LOCK_FILE_NAME);
			
			// copy stuff from staging directory into the live directory
			copyContents(staging, base, STAGING_DIRECTORY_LOCK_FILE_NAME);
			
			return true;
		} finally {
			// delete staging content, including the lock file
			FileUtils.cleanDirectory(staging);
		}
	}
	
	private boolean checkOldVersion(File oldVersionFolder) throws IOException {
		// list files in staging and old-version, except lock and version
		FileFilter filter = createIngoreFilter(STAGING_DIRECTORY_LOCK_FILE_NAME,
				VERSION_INFO_FILE_NAME);
		File[] oldFiles = oldVersionFolder.listFiles(filter);
		File[] stagingFiles = staging.listFiles(filter);
		if (oldFiles.length == stagingFiles.length) {
			Arrays.sort(oldFiles);
			Arrays.sort(stagingFiles);
			boolean equals = true;
			for (int i = 0; i < stagingFiles.length && equals; i++) {
				final File oldFile = oldFiles[i];
				final File stagingFile = stagingFiles[i];
				String oldName = oldFile.getName();
				equals = oldName.equals(stagingFile.getName());
				if (equals) {
					if (!oldFile.isDirectory() && !stagingFile.isDirectory()) {
						if (oldName.toLowerCase().endsWith(".owl")) {
							// skipping owl files for now
							// reason: owl collections are not sorted, thus
							// equivalent collections may have different serializations
							// --> failing equivalence test on file level
							continue;
						}
						// TODO decide, if the binary equals is sufficient
						// What about the embedded data version?
						equals = FileUtils.contentEquals(oldFile, stagingFile);
					} else {
						if (oldFile.isDirectory() && stagingFile.isDirectory()) {
							equals = equalsDirectory(oldFile, stagingFile);
						} else {
							equals = false;
						}
					}
				}
			}
			return equals;
		}
		return false;
	}
	
	private boolean equalsDirectory(File directory1, File directory2) throws IOException {
		if (FileUtils.isSymlink(directory1) || FileUtils.isSymlink(directory2)) {
			return false;
		}
		File[] files1 = directory1.listFiles();
		File[] files2 = directory2.listFiles();
		if (files1.length == 0 && files2.length == 0) {
			return true;
		}
		if (files1.length != files2.length) {
			return false;
		}
		Arrays.sort(files1);
		Arrays.sort(files2);
		boolean equals = true;
		for (int i = 0; i < files1.length && equals; i++) {
			File file1 = files1[i];
			File file2 = files2[i];
			if (file1.isFile() && file2.isFile()) {
				equals = FileUtils.contentEquals(file1, file2);
			}
			else {
				if (file1.isDirectory() && file2.isDirectory()) {
					equals = equalsDirectory(file1, file2);
				}
				else {
					equals = false;
				}
			}
		}
		return equals;
	}

	private void copyContents(File sourceFolder, File targetFolder, final String...ignores) throws IOException {
		FileUtils.copyDirectory(sourceFolder, targetFolder, createIngoreFilter(ignores), true);
	}
	
	
	/**
	 * Clean a directory, by deleting all files and folders in it. Retain the 
	 * top level files or folders, if their names are in the ignores array.
	 * 
	 * @param folder
	 * @param ignores
	 * @throws IOException
	 */
	private void cleanDirectory(final File folder, final String...ignores) throws IOException {
		File[] files = folder.listFiles(createIngoreFilter(ignores));
		if (files.length > 0) {
			logger.info("Cleaning folder: "+folder.getAbsolutePath());
			for (File file : files) {
				if (!FileUtils.isSymlink(file)) {
					// if file is symlink, do not recurse, only delete the link.
					file.delete();
				} else {
					FileUtils.forceDelete(file);
				}
			}
		}
	}
	
	private static FileFilter createIngoreFilter(final String...ignores) {
		FileFilter filter = null;
		if (ignores != null && ignores.length > 0) {
			filter = new FileFilter() {
				Set<String> names = createSet(ignores);
				
//				@Override
				public boolean accept(File pathname) {
					return !names.contains(pathname.getName());
				}
			};
		}
		return filter;
	}
	
	private static <T> Set<T> createSet(T[] values) {
		if (values.length == 1) {
			return Collections.singleton(values[0]);
		}
		return new HashSet<T>(Arrays.asList(values));
	}
	
	static void checkFolder(File folder) throws IOException {
		FileUtils.forceMkdir(folder);
		if (!folder.exists()) {
			throw new IOException("Could not create directory: "+folder.getAbsolutePath());
		}
		if (!folder.isDirectory()) {
			throw new IOException(folder.getAbsolutePath()+" already exists, but is not a directory");
		}
		if (!folder.canWrite()) {
			throw new IOException("Can't write in directory: "+folder.getAbsolutePath());
		}
	}
	
}
